import hashlib
import json
import re
import uuid
from collections import defaultdict
from functools import cached_property

import bleach
from bs4 import BeautifulSoup
from django.conf import settings
from django.contrib import admin
from django.db import models
from django.urls import reverse

from geniza.common.models import TrackChangesModel
from geniza.common.utils import absolutize_url
from geniza.corpus.annotation_utils import document_id_from_manifest_uri


def annotations_to_list(annotations, uri):
    """Generate an AnnotationList from a list of annotations.
    Must specify the uri for the annotation list id.
    Returns a dict that can be serialized as JSON."""
    return {
        "@context": "http://iiif.io/api/presentation/2/context.json",
        "@id": uri,  # @id and not id per iiif spec
        "@type": "sc:AnnotationList",
        # exclude context on individual annotations,
        # redundant within AnnotationList context
        "resources": [a.compile(include_context=False) for a in annotations],
    }


class AnnotationQuerySet(models.QuerySet):
    def by_target_context(self, uri):
        """filter queryset by the context of the target (i.e, the manifest
        the canvas belongs to)"""
        return self.filter(footnote__object_id=document_id_from_manifest_uri(uri))

    def group_by_canvas(self):
        """Aggregate annotations by canvas id; returns a dictionary of lists,
        keys are canvas ids, items are lists of annotations."""
        # aggregate annotations by canvas id
        annos_by_canvas = defaultdict(list)
        for anno in self.all():
            # ignore if target source is unset
            if anno.target_source_id:
                annos_by_canvas[anno.target_source_id].append(anno)
        return annos_by_canvas

    def group_by_manifest(self):
        """Aggregate annotations by manifest uri; returns a dictionary of lists,
        keys are manifest uri, items are lists of annotations."""
        # aggregate annotations by target manifest
        annos_by_manifest = defaultdict(list)
        for anno in self.all():
            # ignore if target source manifest is unset
            if anno.target_source_id:
                annos_by_manifest[anno.target_source_manifest_id].append(anno)
        return annos_by_manifest


class Annotation(TrackChangesModel):
    """Annotation model for storing annotations in the database.

    Annotations may be either block-level or line-level. Block-level annotation is the default;
    in most cases, a block-level annotation's content is stored as a TextualBody in its `content`
    JSON.

    However, block-level annotations may also be used to group line-level annotations, in which case
    they have no textual content themselves, except for an optional label. Instead, their content
    is serialized by joining TextualBody values from all associated line-level annotations.

    Line-level annotations are associated with blocks via the `block` property, and that relationship
    is serialized as `partOf` at the root of the line-level annotation."""

    #: annotation id (uuid, autogenerated when created)
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    #: date created
    created = models.DateTimeField(auto_now_add=True)
    #: date last modified
    modified = models.DateTimeField(auto_now=True)
    #: json content of the annotation. in addition to W3C Web Annotation Data Model properties,
    #: may also include: "schema:position", which tracks the order of the annotation with respect
    #: to others in the same block or canvas; and "textGranularity", which indicates whether this
    #: is a block- or line-level annotation
    content = models.JSONField()
    #: optional canonical identifier, for annotations imported from another source
    canonical = models.CharField(max_length=255, blank=True)
    #: uri of annotation when imported from another copy (optional)
    via = models.URLField(blank=True)
    #: related scholarship record; used for source and manifest uri in JSON serialization
    footnote = models.ForeignKey(
        "footnotes.Footnote",
        on_delete=models.CASCADE,
        null=False,
    )
    #: block-level annotation associated with this (line-level) annotation. if null, this is a
    #: block-level annotation. if a block is deleted, all associated lines will be deleted.
    block = models.ForeignKey(
        to="Annotation",
        on_delete=models.CASCADE,
        related_name="lines",
        null=True,
    )

    # use custom manager & queryset
    objects = AnnotationQuerySet.as_manager()

    # allowed tags and attributes for annotation body content HTML
    ALLOWED_TAGS = ["del", "li", "ol", "p", "span", "sup", "i"]
    ALLOWED_ATTRIBUTES = ["lang"]

    # error message for malformed annotations
    MALFORMED_ERROR = (
        "Malformed annotation. Annotation must include manifest and source URIs."
    )

    class Meta:
        # by default, order by creation time
        ordering = ["created"]

    def __repr__(self):
        return f"<Annotation id:{self.id}>"

    def get_absolute_url(self):
        """url for this annotation (relative to the current application)"""
        return reverse("annotations:annotation", kwargs={"pk": self.pk})

    @admin.display(
        ordering="id",
        description="URI",
    )
    def uri(self):
        """URI for this annotation (absolute url)"""
        return absolutize_url(self.get_absolute_url())

    @cached_property
    def target_source_id(self):
        """convenience method to access target source id"""
        return self.content.get("target", {}).get("source", {}).get("id")

    @cached_property
    def target_source_manifest_id(self):
        """convenience method to access manifest id for target source"""
        return "%s%s" % (
            settings.ANNOTATION_MANIFEST_BASE_URL,
            reverse("corpus-uris:document-manifest", args=[self.footnote.object_id]),
        )

    @cached_property
    def label(self):
        """convenience method to get annotation label"""
        try:
            return self.content.get("body", [])[0].get("label", "")
        except IndexError:
            pass

    @cached_property
    def body_content(self):
        """convenience method to get annotation body content"""
        try:
            return self.content.get("body", [])[0].get("value", "")
        except IndexError:
            pass

    @cached_property
    def block_content_html(self):
        """convenience method to get HTML content, including label and any associated lines,
        of a block-level annotation, as a list of HTML strings"""
        content = []
        if self.label:
            content.append(f"<h3>{self.label}</h3>")
        if self.has_lines:
            # if this block annotation has separate line annotations, serialize as ordered list
            content.append("<ol>")
            for l in self.lines.all().order_by("content__schema:position"):
                content.append(f"<li>{l.body_content}</li>")
            content.append("</ol>")
        elif self.body_content:
            content.append(self.body_content)
        return content

    @cached_property
    def has_lines(self):
        """cached property to indicate whether or not this is a block-level
        annotation with line-level children"""
        return self.lines.exists()

    def set_content(self, data):
        """Set or update annotation content and model fields.

        If :attr:`via` or :attr:`canonical` are set and the values
        differ in the new data, a :class:`ValueError` exception will be raised
        and the data will not be saved.
        """
        # remove any values tracked on the model; redundant in json field
        for val in ["id", "created", "modified", "@context", "type", "etag"]:
            if val in data:
                del data[val]

        # store via and canonical if set; error if set and different
        if "canonical" in data:
            if self.canonical and self.canonical != data["canonical"]:
                # TODO: custom exception?
                raise ValueError("canonical id differs")
            self.canonical = data["canonical"]
            del data["canonical"]
        if "via" in data:
            if self.via and self.via != data["via"]:
                raise ValueError("canonical id differs")
            self.via = data["via"]
            del data["via"]

        # sanitize any html in body value
        if len(data.get("body", [])) and "value" in data["body"][0]:
            data["body"][0]["value"] = self.sanitize_html(
                data.get("body", [])[0].get("value", "")
            )

        self.content = data

    @classmethod
    def sanitize_html(cls, html):
        """Sanitizes passed HTML according to allowed tags and attributes, stripping out any
        that are not allowed, and spans with no attributes."""
        # strip down to allowed tags and attributes
        cleaned_html = bleach.clean(
            html,
            tags=cls.ALLOWED_TAGS,
            attributes=cls.ALLOWED_ATTRIBUTES,
            strip=True,
        )

        # replace Unicode non-breaking space \xa0
        cleaned_html = re.sub(r"[\xa0 ]+", " ", cleaned_html)

        # if resulting text has any span elements with no attributes, remove them
        if "<span>" in cleaned_html:
            # parse as html to identify spans with no attributes
            soup = BeautifulSoup(cleaned_html)
            for span in soup.find_all("span"):
                # if span has no attributes, unwrap the text and remove the span tag
                if not span.attrs:
                    span.unwrap()
            # serialize back out as html without wrapping html/body tags
            return "".join(str(el) for el in soup.html.body.children)

        else:
            return cleaned_html

    @property
    def etag(self):
        """Compute and return an md5 hash of content to use as an ETag.

        NOTE: Only :attr:`content` can be modified in the editor, so it is the only hashed
        attribute. If other attributes become mutable, modify this function to include them in
        the ETag computation."""
        # must be a string encoded as utf-8 to compute md5 hash
        content_str = json.dumps(self.content, sort_keys=True).encode("utf-8")
        # ETag should be wrapped in double quotes, per Django @condition docs
        return f'"{hashlib.md5(content_str).hexdigest()}"'

    def compile(self, include_context=True):
        """Combine annotation data and return as a dictionary that
        can be serialized as JSON.  Includes context by default,
        but may be omitted when annotation will be included in context
        that already has it defined."""

        # by default, include annotation context;
        # redundant when included in annotation list or container
        anno = {}
        if include_context:
            anno = {"@context": "http://www.w3.org/ns/anno.jsonld"}
        else:
            # NOTE: ETag required here for inclusion in annotation list, which is how
            # annotations are fetched during editing; need to associate each ETag with
            # an individual annotation, for comparison with response ETag on POST/DELETE
            anno = {"etag": self.etag}

        # define fields in desired order
        anno.update(
            {
                "id": self.uri(),
                "type": "Annotation",
                "created": self.created.isoformat(),
                "modified": self.modified.isoformat(),
            }
        )
        if self.canonical:
            anno["canonical"] = self.canonical
        if self.via:
            anno["via"] = self.via

        # populate source and manifest uri based on footnote and
        # related source/document objects
        if self.footnote:
            anno["dc:source"] = self.footnote.source.uri
            anno["target"] = self.content["target"] if "target" in self.content else {}
            if "source" not in anno["target"]:
                anno["target"]["source"] = {}
            anno["target"]["source"]["partOf"] = {
                "id": self.footnote.content_object.manifest_uri
            }

        # make a copy of the base annotation data
        base_anno = anno.copy()
        # update with the rest of the annotation content
        anno.update(self.content)
        # overwrite with the base annotation data in case of any collisions
        # between content and model fields
        anno.update(base_anno)

        # if this is a line-level annotation with block, include in content
        if self.block:
            anno.update({"partOf": self.block.uri()})

        return anno
