import uuid
from collections import defaultdict
from functools import cached_property

import bleach
from django.contrib import admin
from django.db import models
from django.urls import reverse

from geniza.common.utils import absolutize_url


def annotations_to_list(annotations, uri):
    """Generate an AnnotationList from a list of annotations.
    Must specify the uri for the annotation list id.
    Returns a dict that can be serialized as JSON."""
    return {
        "@context": "http://iiif.io/api/presentation/2/context.json",
        "@id": uri,  # @id and not id per iiif spec
        "@type": "sc:AnnotationList",
        # exclude context on individual annotations,
        # redundant within AnnotationList context
        "resources": [a.compile(include_context=False) for a in annotations],
    }


class AnnotationQuerySet(models.QuerySet):
    def by_target_context(self, uri):
        """filter queryset by the context of the target (i.e, the manifest
        the canvas belongs to)"""
        return self.filter(content__target__source__partOf__id=uri)

    def group_by_canvas(self):
        """Aggregate annotations by canvas id; returns a dictionary of lists,
        keys are canvas ids, items are lists of annotations."""
        # aggregate annotations by canvas id
        annos_by_canvas = defaultdict(list)
        for anno in self.all():
            # ignore if target source is unset
            if anno.target_source_id:
                annos_by_canvas[anno.target_source_id].append(anno)
        return annos_by_canvas


class Annotation(models.Model):
    """Annotation model for storing annotations in the database."""

    #: annotation id (uuid, autogenerated when created)
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    #: date created
    created = models.DateTimeField(auto_now_add=True)
    #: date last modified
    modified = models.DateTimeField(auto_now=True)
    #: json content of the annotation
    content = models.JSONField()
    #: optional canonical identifier, for annotations imported from another source
    canonical = models.CharField(max_length=255, blank=True)
    #: uri of annotation when imported from another copy (optional)
    via = models.URLField(blank=True)

    # use custom manager & queryset
    objects = AnnotationQuerySet.as_manager()

    # allowed tags and attributes for annotation body content HTML
    ALLOWED_TAGS = ["del", "li", "ol", "p", "span", "sup"]
    ALLOWED_ATTRIBUTES = ["lang"]

    class Meta:
        # by default, order by creation time
        ordering = ["created"]

    def __repr__(self):
        return f"<Annotation id:{self.id}>"

    def get_absolute_url(self):
        """url for this annotation (relative to the current application)"""
        return reverse("annotations:annotation", kwargs={"pk": self.pk})

    @admin.display(
        ordering="id",
        description="URI",
    )
    def uri(self):
        """URI for this annotation (absolute url)"""
        return absolutize_url(self.get_absolute_url())

    @cached_property
    def target_source_id(self):
        """convenience method to access target source id"""
        return self.content.get("target", {}).get("source", {}).get("id")

    @cached_property
    def target_source_manifest_id(self):
        """convenience method to access manifest id for target source"""
        return (
            self.content.get("target", {}).get("source", {}).get("partOf", {}).get("id")
        )

    @cached_property
    def label(self):
        """convenience method to get annotation label"""
        try:
            return self.content.get("body", [])[0].get("label", "")
        except IndexError:
            pass

    @cached_property
    def body_content(self):
        """convenience method to get annotation body content"""
        try:
            return self.content.get("body", [])[0].get("value", "")
        except IndexError:
            pass

    def set_content(self, data):
        """Set or update annotation content and model fields.

        If :attr:`via` or :attr:`canonical` are set and the values
        differ in the new data, a :class:`ValueError` exception will be raised
        and the data will not be saved.
        """
        # remove any values tracked on the model; redundant in json field
        for val in ["id", "created", "modified", "@context", "type"]:
            if val in data:
                del data[val]

        # store via and canonical if set; error if set and different
        if "canonical" in data:
            if self.canonical and self.canonical != data["canonical"]:
                # TODO: custom exception?
                raise ValueError("canonical id differs")
            self.canonical = data["canonical"]
            del data["canonical"]
        if "via" in data:
            if self.via and self.via != data["via"]:
                raise ValueError("canonical id differs")
            self.via = data["via"]
            del data["via"]

        # sanitize any html in body value
        if len(data.get("body", [])) and "value" in data["body"][0]:
            data["body"][0]["value"] = self.sanitize_html(
                data.get("body", [])[0].get("value", "")
            )

        self.content = data

    @classmethod
    def sanitize_html(cls, html):
        """Sanitizes passed HTML according to allowed tags and attributes, stripping out any
        that are not allowed."""
        return bleach.clean(
            html,
            tags=cls.ALLOWED_TAGS,
            attributes=cls.ALLOWED_ATTRIBUTES,
            strip=True,
        )

    def compile(self, include_context=True):
        """Combine annotation data and return as a dictionary that
        can be serialized as JSON.  Includes context by default,
        but may be omitted when annotation will be included in context
        that already has it defined."""

        # by default, include annotation context;
        # redundant when included in annotation list or container
        anno = {}
        if include_context:
            anno = {"@context": "http://www.w3.org/ns/anno.jsonld"}

        # define fields in desired order
        anno.update(
            {
                "id": self.uri(),
                "type": "Annotation",
                "created": self.created.isoformat(),
                "modified": self.modified.isoformat(),
            }
        )
        if self.canonical:
            anno["canonical"] = self.canonical
        if self.via:
            anno["via"] = self.via
        # make a copy of the base annotation data
        base_anno = anno.copy()
        # update with the rest of the annotation content
        anno.update(self.content)
        # overwrite with the base annotation data in case of any collisions
        # between content and model fields
        anno.update(base_anno)
        return anno
