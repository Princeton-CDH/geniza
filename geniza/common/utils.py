import time

from django.conf import settings
from django.contrib.sites.models import Site
from taggit.utils import _parse_tags
from unidecode import unidecode


def absolutize_url(local_url, request=None):
    """Convert a local url to an absolute url, with scheme and server name,
    based on the current configured :class:`~django.contrib.sites.models.Site`.
    :param local_url: local url to be absolutized, e.g. something generated by
        :meth:`~django.urls.reverse`
    """
    # Borrowed from https://github.com/Princeton-CDH/mep-django/blob/main/mep/common/utils.py

    if local_url.startswith("https"):
        return local_url

    # add scheme and server (i.e., the http://example.com) based
    # on the django Sites infrastructure.
    root = Site.objects.get_current().domain
    # add http:// if necessary, since most sites docs
    # suggest using just the domain name
    if not root.startswith("http"):
        # if DJANGO_ENV is set to development, assume not https
        if settings.ENV == "development":
            root = "http://%s" % root
        # if in debug mode and request is passed in, use
        # the current scheme (i.e. http for localhost/runserver)
        elif settings.DEBUG and request:
            root = "%s://%s" % (request.scheme, root)
        # assume https for production sites
        else:
            root = "https://" + root

    # make sure there is no double slash between site url and local url
    if local_url.startswith("/"):
        root = root.rstrip("/")

    return root + local_url


def custom_tag_string(tag_string):
    """
    Custom tag parsing for taggit to better support multi-word tags and case-insensitivity,
    and to convert any Unicode to ASCII.

    Expected parsing:
    - 'legal document' -> ["legal document"]
    - '"fiscal document", Arabic script' -> ["fiscal document", "Arabic script"]
    - '"fiscal document", "Arabic script"' -> ["fiscal document", "Arabic script"]
    - 'éxämplè' -> ["example"]

    This is configured in settings with TAGGIT_TAGS_FROM_STRING.

    NOTE: Only runs on related save (i.e. tagging an instance of another model). For new tags
    created separately, use a signal handler in :class:`~geniza.corpus.models.TagSignalHandlers`.
    """
    # Stack overflow solution: https://stackoverflow.com/questions/30513783/django-taggit-how-to-allow-multi-word-tags
    # Our github issue for taggit: https://github.com/jazzband/django-taggit/issues/783
    if "," not in tag_string:
        tag_string += ","
    return _parse_tags(unidecode(tag_string))


# translation table for curly/typograghic single and double quotes
smart_quote_conversion = str.maketrans(
    {
        "’": "'",
        "‘": "'",
        "”": '"',
        "“": '"',
        "״": '"',
    }
)


def simplify_quotes(text):
    return text.translate(smart_quote_conversion)


def list_to_string(lst):
    """Helper function to join a list with commas, and 'and' before the final
    entry."""
    return " and ".join([", ".join(lst[:-1]), lst[-1]] if len(lst) > 2 else lst)


## adapted from tabular_export.admin
class Echo(object):
    # See https://docs.djangoproject.com/en/1.8/howto/outputting-csv/#streaming-csv-files
    def write(self, value):
        return value

    def __enter__(self, *x, **y):
        return self

    def __exit__(self, *x, **y):
        return


class Timer:
    def __init__(self, desc="Timer", to_print=True, print_func=None):
        self.desc = desc
        self.to_print = to_print
        self.print_func = print_func if print_func is not None else print

    def __enter__(self):
        self.now = time.time()
        self.print(f"{self.desc} ...", end="\n")
        self.t = self.elapsed = 0
        return self

    def __exit__(self, *x, **y):
        self.t = self.elapsed = time.time() - self.now
        self.print(f"{self.desc} completed in {round(self.elapsed,1)}s", end="\n\n")

    def print(self, x, end="\n"):
        if self.to_print:
            self.print_func(x, end=end)


class Timerable:
    def timer(self, desc="", to_print=True, print_func=None):
        # get description
        if not desc:
            desc = self.__class__.__name__

        # get print function
        if not callable(print_func):
            if hasattr(self, "print") and callable(self.print):
                print_func = self.print
            else:
                print_func = print

        # return a timer
        return Timer(desc=desc, to_print=to_print, print_func=print_func)
