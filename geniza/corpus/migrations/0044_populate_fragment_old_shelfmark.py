# Generated by Django 3.2.16 on 2023-11-01 18:03

import re

from django.db import migrations

# simple pairs
shelfmark_pairs = {
    # {replaceable string in new shelfmark: replacement for historical shelfmarks}
    "CUL Add.": ["ULC Add. "],
    "Halper": ["Dropsie"],
    "JRL Gaster ar.": [
        "John Rylands Library, Manchester, Gaster Collection, Arabic Series",
    ],
    "L-G Misc. ": [
        "West. Coll. (Westminster College), Frag. Cairens., f. ",
        "West. Coll. (Westminster College), Frag. Cairens., fol. ",
    ],
    "L-G Glass ": [
        "West. Coll. (Westminster College), Fragments under Glass, f. ",
        "West. Coll. (Westminster College), Fragments under Glass, fol. ",
    ],
    "NLI": ["JNL", "JNUL"],
    "T-S Misc. 35.": ["TS Loan 38."],
    "T-S Misc.35.": ["TS Loan 38."],
    "T-S Misc.36.": ["TS Loan 38."],
    "UPenn E": ["Philadelphia"],
}

# complex pairs require regex
shelfmark_regex_pairs = {
    # {new shelfmark regex: historical shelfmark regex for re.sub}
    # AIU VI.B.101 --> AIU VI B 101
    r"^AIU ([A-Z]+)\.([A-Z]+)\.([\da-z–]+)": [r"AIU \1 \2 \3"],
    # AIU XII.87 --> AIU XII 87
    r"^AIU ([A-Z]+)\.(\d+)": [r"AIU \1 \2"],
    # BL OR 10110.23 --> BM Or 10110, f. 23
    r"^BL OR ([A-Z\d()]+)\.?\/?([\da-z–]+)": [r"BM Or \1, f. \2", r"BM Or \1, fol. \2"],
    # Bodl. MS heb. b 12/6 --> Bodl. MS Heb. b 12, f. 6
    r"^Bodl\. MS [Hh]eb\. ([A-Za-z]) ?\.?(\d+)\/([\d–]+)": [
        r"Bodl. MS Heb. \1 \2, f. \3",
        r"Bodl. MS Heb. \1 \2, fol. \3",
    ],
    # CUL Or.2116.10 --> ULC Or 2116, f. 10
    r"^CUL Or\.\ ?(\d+)\.(\d+)": [r"ULC Or \1, f. \2", r"ULC Or \1, fol. \2"],
    # CUL Or.1081 2.6 --> ULC Or 2116 Box 2 f. 6
    r"^CUL Or\.(\d+) (\d+)\.(.+)": [
        r"ULC Or \1 Box \2 f. \3",
        r"ULC Or \1 Box \2 fol. \3",
    ],
    # CUL Or.1080 J55 --> ULC Or 1080 J 55
    r"^CUL Or\.(\d+) ([A-Z])([\d\.]+)": [r"ULC Or \1 \2 \3"],
    # ENA 2149.49 --> ENA 2149, f. 49
    r"^ENA (\d+)\.([\dA-Za-z–]+)": [r"ENA \1, f. \2", r"ENA \1, fol. \2"],
    # ENA NS 31.3  --> ENA NS 31, f. 3
    r"^ENA NS ([A-Z\d]+)\.([a-z\d\.]+)": [r"ENA NS \1, f. \2", r"ENA NS \1, fol. \2"],
    # L-G Ar. II.87 --> West. Coll. (Westminster College), Ar(abica) II, f. 87
    r"^L-G Ar\. ([A-Z]+)\.([\d–.]+)": [
        r"West. Coll. (Westminster College), Ar. (Arabica) \1, f. \2",
        r"West. Coll. (Westminster College), Ar. (Arabica) \1, fol. \2",
    ],
    r"^L-G Bib\.\ ?([A-Z]+)\.([\d–.]+)": [
        r"West. Coll. (Westminster College), Bib. (Bible) \1, f. \2",
        r"West. Coll. (Westminster College), Bib. (Bible) \1, fol. \2",
    ],
    r"^L-G Lit\.\ ?([A-Z]+)\.([\d–.]+)": [
        r"West. Coll. (Westminster College), Lit. (Liturgy) \1, f. \2",
        r"West. Coll. (Westminster College), Lit. (Liturgy) \1, fol. \2",
    ],
    r"^L-G Talm?\.\ ?([A-Z]+)\.([\d–.]+)": [
        r"West. Coll. (Westminster College), Tal. (Talmud) \1, f. \2",
        r"West. Coll. (Westminster College), Tal. (Talmud) \1, fol. \2",
    ],
    # T-S A–K#.# --> TS A-K number, f. number (and sometimes TS Box)
    r"^T\-S ([A-K])(\d+)\.(\d+)": [
        r"TS \1, \2, f. \3",
        r"TS Box \1, \2, f. \3",
        r"TS \1, \2, fol. \3",
        r"TS Box \1, \2, fol. \3",
    ],
    # T-S Ar.30.284 --> TS Arabic Box 30, f. 284
    r"^T-S Ar\.?\ ?(\d+)\.(.+)": [
        r"TS Arabic Box \1, f. \2",
        r"TS Arabic Box \1, fol. \2",
    ],
    # T-S Misc. 8.65 --> TS Box Misc. 8, f. 65
    r"^T-S Misc\.?\ ?(\d+)\.(.+)": [
        r"TS Box Misc. \1, f. \2",
        r"TS Box Misc. \1, fol. \2",
    ],
    # T-S 10J27.3 --> TS 10 J 27, f. 3 (and sometimes TS Box)
    r"^T\-S (\d+)([A-Z])(\d+)\.?\–?(\d+)": [
        r"TS \1 \2 \3, f. \4",
        r"TS Box \1 \2 \3, f. \4",
        r"TS \1 \2 \3, fol. \4",
        r"TS Box \1 \2 \3, fol. \4",
    ],
}

ROMAN = [(50, "L"), (40, "XL"), (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")]


def int_to_roman(number):
    # thanks to https://stackoverflow.com/a/47713392/394067
    result = ""
    for arabic, roman in ROMAN:
        (factor, number) = divmod(number, arabic)
        result += roman * factor
    return result


def gottheil_repl(match):
    roman = int_to_roman(int(match.group("numeral")))
    return f"Gottheil-Worrell {roman}"


def populate_old_shelfmarks(apps, schema_editor):
    Fragment = apps.get_model("corpus", "Fragment")

    # for the simple pairs, just use find and replace on the current shelfmarks
    for shelfmark, historical_shelfmarks in shelfmark_pairs.items():
        # all keys in the shelfmark_pairs dict have been written for a __startswith query
        for frag in Fragment.objects.filter(shelfmark__startswith=shelfmark):
            # create historical shelfmarks
            hist = [frag.shelfmark.replace(shelfmark, s) for s in historical_shelfmarks]
            # include existing old shelfmarks if any present
            # use set to avoid duplicates
            historical_shelfmark_set = (
                set([frag.old_shelfmarks, *hist]) if frag.old_shelfmarks else set(hist)
            )
            # join all historical shelfmarks by semicolon
            frag.old_shelfmarks = "; ".join(historical_shelfmark_set)

    # More complex combinations require regex (sadly no named groups in regex django query)
    for shelfmark_regex, historical_regex in shelfmark_regex_pairs.items():
        for frag in Fragment.objects.filter(shelfmark__regex=shelfmark_regex):
            # use re.sub to generate historical shelfmarks with regex
            hist = [
                re.sub(shelfmark_regex, s, frag.shelfmark) for s in historical_regex
            ]
            # set of all historical shelfmarks to avoid duplicates
            historical_shelfmark_set = (
                set([frag.old_shelfmarks, *hist]) if frag.old_shelfmarks else set(hist)
            )
            frag.old_shelfmarks = "; ".join(historical_shelfmark_set)

    # finally, freer is perhaps the most complex of all! we need to take the existing
    # historical shelfmark, if present, and convert its numeral to roman numerals.
    freer_regex = r"Gottheil-Worrell (?P<numeral>\d+)"
    for frag in Fragment.objects.filter(shelfmark__startswith="F 1908.44"):
        # these three Gottheil-Worrell historical shelfmarks are not yet present
        if "1908.44S" in frag.shelfmark:
            hist = "Gottheil-Worrell 19; Gottheil-Worrell XIX"
        elif "1908.44U" in frag.shelfmark:
            hist = "Gottheil-Worrell 21; Gottheil-Worrell XXI"
        elif "1908.44UU" in frag.shelfmark:
            hist = "Gottheil-Worrell 47; Gottheil-Worrell XLVII"
        else:
            # use regex for the rest
            hist = re.sub(freer_regex, gottheil_repl, frag.old_shelfmarks)
        frag.old_shelfmarks = (
            f"{frag.old_shelfmarks}; {hist}" if frag.old_shelfmarks else hist
        )


class Migration(migrations.Migration):
    dependencies = [
        ("corpus", "0043_document_cleanup_nbsp"),
    ]

    operations = [
        migrations.RunPython(
            populate_old_shelfmarks, reverse_code=migrations.RunPython.noop
        )
    ]
