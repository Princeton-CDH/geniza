from django.db import models
from taggit.managers import TaggableManager

class Collection(models.Model):
    '''Collection at a library that holds Geniza fragments'''
    library = models.CharField(max_length=255)
    abbrev = models.CharField('Abbreviation', max_length=255, unique=True)
    collection = models.CharField(
        max_length=255, blank=True,
        help_text='Collection name, if different than Library')
    location = models.CharField(
        max_length=255, help_text='Current location of the collection')

    class Meta:
        ordering = ['abbrev']
        constraints = [
            models.UniqueConstraint(fields=['library', 'collection'],
                                    name='unique_library_collection')
        ]

    def __str__(self):
        return self.abbrev


class LanguageScript(models.Model):
    '''Combination language and script'''
    language = models.CharField(max_length=255)
    script = models.CharField(max_length=255)
    display_name = models.CharField(
        max_length=255, blank=True, unique=True, null=True,
        help_text="Option to override the autogenerated language-script name")

    class Meta:
        ordering = ['language']
        constraints = [
            models.UniqueConstraint(fields=['language', 'script'],
                                    name='unique_language_script')
        ]

    def __str__(self):
        # Allow display_name to override autogenerated string
        # otherwise combine language and script
        #   e.g. Judaeo-Arabic (Hebrew script)
        return self.display_name or f"{self.language} ({self.script} script)"


class Fragment(models.Model):
    shelfmark = models.CharField(max_length=255, unique=True)
    library = models.ForeignKey(Library, blank=True, on_delete=models.SET_NULL, null=True)
    # multiple, semicolon-delimited values. Keeping as single-valued for now
    old_shelfmarks = models.CharField(max_length=255, blank=True)
    url = models.URLField('URL', blank=True, help_text="Link to library's catalog record for this fragment.")
    iiif_url = models.URLField('URL', blank=True)
    notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.shelfmark


class DocumentType(models.Model):
    '''The category of document in question.'''
    name = models.CharField(max_length=255, unique=True)

    def __str__(self):
        return self.name


class Document(models.Model):
    '''A unified document such as a letter or legal document that
    appears on one or more fragments.'''
    id = models.AutoField('PGPID', primary_key=True)
    fragments = models.ManyToManyField(Fragment, through='DocumentFragment')
    languages = models.ManyToManyField(LanguageScript, blank=True)
    description = models.TextField(blank=True)
    doctype = models.ForeignKey(
        DocumentType, blank=True, on_delete=models.SET_NULL, null=True)
    tags = TaggableManager()
    old_input_by = models.CharField(
        max_length=255,
        help_text='Legacy input information from Google Sheets')
    old_input_date = models.CharField(
        max_length=255,
        help_text='Legacy input date from Google Sheets')
    created = models.DateTimeField(auto_now_add=True)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.shelfmark

    @property
    def shelfmark(self):
        return ' + '.join([fragment.shelfmark
                           for fragment in self.fragments.all()])

    @property
    def library(self):
        return ', '.join(set([fragment.library.abbrev for
                              fragment in self.fragments.all()]))


class DocumentFragment(models.Model):
    '''Document-Fragment through model'''
    document = models.ForeignKey(Document, on_delete=models.CASCADE)
    fragment = models.ForeignKey(Fragment, on_delete=models.CASCADE)
    text_block = models.CharField(max_length=255)
    multifragment = models.CharField(max_length=255)

    RECTO = 'r'
    VERSO = 'v'
    RECTO_VERSO = 'rv'
    RECTO_VERSO_CHOICES = [
        (RECTO, 'Recto'),
        (VERSO, 'Verso'),
        (RECTO_VERSO, 'Recto and Verso'),
    ]
    side = models.CharField(blank=True, max_length=255, choices=RECTO_VERSO_CHOICES)
