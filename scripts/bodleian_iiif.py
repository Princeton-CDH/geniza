#! /usr/bin/env python

"""
Stand-alone python script to generate IIIF manifests
for Bodleian Genizah content.

Bodleian Genizah TEI files are available in the collections folder
of this GitHub repository: https://github.com/bodleian/genizah-mss

Install python dependencies with pip:

   pip install eulxml python-slugify requests iiif iiif-prezi
   eulxml is replaced by neuxml to support Python 3.12 summer of 2025

Run with the path to one or more Bodleian TEI files. You must also
specify an output directory and a base url where the iiif content
will be published. For example:

    python scripts/bodleian_iiif.py -d ../iiif/bodleian \
       -u https://princetongenizalab.github.io/iiif/bodleian/ \
       ../genizah-mss/collections/MS_Heb_f_30.xml

Steps to get Bodleian images and generate manifests:

1. Run the script in `--download-only` mode to get all the JPGs for
   a TEI collection or set of them
2. Convert JPGs to pyramidal tiffs using `gen_ptiffs.py` script
3. Run the script in `--check-images` mode to check that you have
   everything. Document any missing images in the static iiif
   README for the Bodleian content.
4. Upload pyramidal tiffs to the IIIF image server.
5. Run this script to generate manifests; canvases will be added based
   on the IIIF image response from the IIIF image server.
6. Use `manifests_to_csv.py` to generate a CSV of manifests and shelfmarks
   for import into PGP application.
"""


import argparse
import os
import os.path
import re

import requests
from iiif_prezi.factory import ManifestFactory
from neuxml import xmlmap
from neuxml.xmlmap import teimap
from slugify import slugify

# parse bodleian tei files, generate iiif manifests,
# and download original images;

# in bodleian tei repo,
# collections is a directory of xml files
# each file has multiple records

# full-size images referenced in TEI can be downloaded in JPG format
# under this base image url
BASE_IMG_URL = "https://genizah.bodleian.ox.ac.uk/fragments/full/"

# bodleian IIIF images hosted by PUL
BASE_IIIF_IMG_URI = "https://puliiif.princeton.edu/iiif/2/"

# define eulxml.xmlmap objects with mapping to the portions of the
# Bodleian XML we care about for generating manifests


class Locus(teimap.Tei):
    # folio range is indicated by locus from/to
    # <locus from="10a" to="20b"/>
    folio_start = xmlmap.StringField("@from")
    folio_end = xmlmap.StringField("@to")


class Folio(teimap.Tei):
    # some msItem will have the entire range of folios in a single tei:locus node
    locus = xmlmap.NodeField("tei:locus", Locus)
    # sometimes there are multiple tei:locus nodes grouped in a tei:locusGrp instead
    locus_group = xmlmap.NodeListField("tei:locusGrp/tei:locus", Locus)
    # sometimes the locus is nested inside a <p> node
    p_locus = xmlmap.NodeField("tei:p/tei:locus", Locus)


class Shelfmark(teimap.Tei):
    xml_id = xmlmap.StringField("@xml:id")
    shelfmark = xmlmap.StringField("tei:msIdentifier/tei:altIdentifier/tei:idno")
    title = xmlmap.StringField("tei:msContents/tei:msItem/tei:title")

    # some msPart will have the entire range of folios in a single tei:locus node
    locus = xmlmap.NodeField("tei:msContents/tei:msItem/tei:locus", Locus)
    # sometimes, folios are indicated by nested msItem only, and we need to split them
    # into separate manifests
    folios = xmlmap.NodeListField("tei:msContents/tei:msItem/tei:msItem", Folio)
    # in at least one case (MS. Heb. e. 56/2), folio range is only in text in a note!
    note = xmlmap.StringField("tei:msContents/tei:msItem/tei:note")


class BodleianGenizahTei(teimap.Tei):
    # extend eulxml TEI to add mappings for the fields we need
    # to generate iiif content

    # volume id on the TEI element
    volume_id = xmlmap.StringField("@xml:id")
    # records with shelfmarks are usually in msPart
    parts = xmlmap.NodeListField("//tei:msPart", Shelfmark)
    # sometimes, records are in msDesc instead
    desc = xmlmap.NodeField("//tei:msDesc", Shelfmark)
    # in the latter case, parts don't have individual shelfmarks, so we need to generate them
    # based on the full manuscript shelfmark
    manuscript = xmlmap.StringField("//tei:msDesc/tei:msIdentifier/tei:idno")
    # images are all listed as graphics under facsimile
    image_urls = xmlmap.StringListField("//tei:facsimile/tei:graphic/@url")


# bodleian image filenames end with a or b;
# translate those to recto/verso for lbaels
image_labels = {"a": "recto", "b": "verso"}

# common metadata to include in all manifests
common_metadata = {
    "Provenance": 'Static IIIF generated by the Center for Digital Humanities at Princeton and the Princeton Geniza Lab from <a href="http://genizah.bodleian.ox.ac.uk/">Genizah Fragments at the Bodleian Libraries</a>, University of Oxford.'
}
attribution = "Images Â© Bodleian Libraries, University of Oxford. <a href=\"https://creativecommons.org/licenses/by-nc/4.0/\">CC-BY-NC 4.0</a>. For more information, please see <a href='https://genizah.bodleian.ox.ac.uk/terms'>Terms of Use</a>."
license_uri = "https://creativecommons.org/licenses/by-nc/4.0/"

# attribution adapted from one of their digital bodleian manifests,
# but linking to Genizah site Terms of Use
# https://iiif.bodleian.ox.ac.uk/iiif/manifest/01bc51ec-80fb-4318-aaf3-bc313692691f.json

# logo image from a bodleian manifest
bodleian_logo = "https://iiif.bodleian.ox.ac.uk/iiif/image/f27e28db-0b08-4f16-9bdf-3565f591fb71/full/256,/0/default.jpg"

# format string for generating view url
view_url_format = "https://genizah.bodleian.ox.ac.uk/catalog/%(volume_id)s#%(item_id)s"

# folio ranges by shelfmark for folios that have images, but are skipped in TEI
skipped_folio_shelfmarks = {
    "MS. Heb. c. 13/3": [3, 4],
}


def image_output_path(image_dir, image_filename):
    # generate the path where we will save the full size version
    # - xml references tiffs but version online is jpg
    return os.path.join(image_dir, image_filename.replace(".tif", ".jpg"))


def image_label(image_filename, xml_id):
    # given an image url like MS_HEB_b_1_1a.tif we want just the 1a portion
    # first remove the file extension
    stem = os.path.splitext(image_filename)[0].lower()
    # use xml_id so that we can handle cases like MS_HEB_d_35_63_biss_a.tif
    # NOTE: in cases like MS_HEB_e_52(R)_1a.tif, image filenames use (P) and (R)
    # instead of xml:id _P and _R.
    # and in the tei for MS_Heb_f_98-star, image filenames use "add" instead of "star".
    to_remove = (
        xml_id.replace("_P", "(P)")
        .replace("_R", "(R)")
        .replace("-star", "_add")
        .lower()
    )
    return stem.replace("%s_" % to_remove, "")


def get_number(some_string):
    # helper method to get a number from a string
    return int(re.sub("[^0-9]", "", some_string))


def get_folio_numbers(locus):
    # get a list of folio numbers from a tei:locus node
    if locus and locus.folio_start and locus.folio_end:
        start_number = get_number(locus.folio_start)
        end_number = get_number(locus.folio_end)
        # if folio_start and folio_end contain different numbers (i.e. multiple folios),
        # then this needs to be multiple manifests, so make sure we include each unique number
        return list(range(start_number, end_number + 1))
    return []


def parse_note(note):
    # in at least one case (MS. Heb. e. 56/2) folio number list only exists in a text note
    if note:
        # get the first two nubmers in the note, should be folio range
        number_list = re.findall("(\d+)", note)
        if len(number_list) >= 2:
            return list(range(int(number_list[0]), int(number_list[1]) + 1))
    return []


def parse_bodleian_tei(xmlfile, base_dir, base_url, image_dir, download_only=False):
    print("Processing %s" % xmlfile)
    tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)

    # put manifests in the directory specified
    manifest_dir = base_dir

    # strip any trailing slash from base url to avoid double or missing slash
    base_url = base_url.rstrip("/")

    # determine path based on the collection filename and part id
    basename = os.path.splitext(os.path.basename(xmlfile))[0]

    # make sure output dirs exist
    os.makedirs(manifest_dir, exist_ok=True)
    os.makedirs(image_dir, exist_ok=True)

    # initialize manifest factory with base urls and iiif api version
    fac = ManifestFactory()
    fac.set_debug("error")  # suppress warnings
    # Where the resources live on the web
    fac.set_base_prezi_uri(base_url)
    # Where the resources live on disk
    fac.set_base_prezi_dir(manifest_dir)

    # Default Image API information
    fac.set_base_image_uri(BASE_IIIF_IMG_URI)
    fac.set_iiif_image_info(2.0, 2)  # Version, ComplianceLevel

    # handle rare cases where we have a bare msDesc with no msPart
    parts = tei.parts or [tei.desc]

    for part in parts:
        # create at least one new manifest per msPart; save to filename based on shelfmark
        # instead of manifest.json

        # when we have only msDesc and no msPart, construct shelfmark from entire manuscript
        # shelfmark with a /1; the number may be replaced when constructing revised_shelfmark
        # from folios
        shelfmark = part.shelfmark or "%s/1" % tei.manuscript

        # ident="%s/%s" % (slugify(series), slugify(shelfmark)),

        # group manifests, so that the directories will be more manageable.
        # use the first portion of the id (e.g., MS. Heb a.),
        # slugify, and then remove ms-heb- since almost all of them have that
        group = slugify("-".join(shelfmark.split(" ")[:3])).replace("ms-heb-", "")

        folio_numbers = []
        if shelfmark in skipped_folio_shelfmarks.keys():
            # special case: handle folios that have images, but are skipped in TEI
            folio_numbers = skipped_folio_shelfmarks[shelfmark]
        elif part.locus:
            # most common case: msPart has a locus with @from and @to, which contains
            # the entire range of folio numbers under this shelfmark, in sequence
            folio_numbers = get_folio_numbers(part.locus)
        elif part.folios:
            # sometimes multiple folios are nested under an msItem
            for folio in part.folios:
                folio_numbers += get_folio_numbers(folio.locus or folio.p_locus)
                # sometimes they are double nested! (e.g. MS_Heb_b_17-part13-item1-item3)
                for nested_folio in folio.locus_group:
                    folio_numbers += get_folio_numbers(nested_folio)
        elif part.note and len(parse_note(part.note)):
            folio_numbers = parse_note(part.note)
        elif "MS. Heb. e. 58 (R)" in shelfmark:
            # special case for MS. Heb. e. 58 (R); 3 images, 2 folios
            folio_numbers = [1, 2]
        else:
            # if we can't get any reference to folios from the XML otherwise,
            # then just use the trailing number from the shelfmark.
            # NOTE: this is unlikely to happen since all folio listing formats
            # should be accounted for. only known cases are MS_Heb_c_14_R.xml,
            # MS_Heb_e_58_R.xml, and MS_Heb_e_62.xml.
            folio_numbers = []
            print("Folio numbers not found in XML for %s; skipping" % (shelfmark))

        # create a separate emanifest for each folio number
        for manifest_number in folio_numbers:
            # in case we need to change numbering due to multiple folios in one shelfmark,
            # revise shelfmark to use current index as number
            revised_shelfmark = "%s/%d" % (shelfmark.rsplit("/", 1)[0], manifest_number)
            # special case: MS Heb. c. 6-8 are combined into one recto/verso image pair
            if revised_shelfmark == "MS. Heb. c. 13/6":
                revised_shelfmark = "MS. Heb. c. 13/6-8"
            # revise the manifest_id in the same way
            manifest_id = slugify(revised_shelfmark)
            # special case: don't renumber MS. Heb. c. 13/6-8 to just 6
            if revised_shelfmark != "MS. Heb. c. 13/6-8":
                manifest_id = "%s-%d" % (manifest_id.rsplit("-", 1)[0], manifest_number)
            # create the grouping directory if it does not exist
            group_dir = os.path.join(manifest_dir, group)
            os.makedirs(group_dir, exist_ok=True)
            # path is based on manifest identifier, in output dir, with json extension
            expected_path = os.path.join(group_dir, "%s.json" % manifest_id)
            # skip if already generated in a previous run
            # if os.path.exists(expected_path):
            #     continue

            # update factory for the current set of records
            fac.set_base_prezi_uri("%s/%s/" % (base_url, group))
            # Where the resources live on disk
            fac.set_base_prezi_dir(group_dir)

            manifest = fac.manifest(
                ident=manifest_id,
                label=str(revised_shelfmark),
            )
            manifest.viewingHint = "individuals"
            manifest.attribution = attribution
            manifest.license = license_uri
            manifest.set_metadata(common_metadata)
            # set bodleian logo
            manifest.logo = bodleian_logo

            # use title from xml as manifest description
            manifest.description = str(part.title)

            # construct link to this item on Bodleian Genizah site
            view_url = view_url_format % {
                "volume_id": tei.volume_id,
                "item_id": part.xml_id,
            }
            manifest.rendering = {
                "@id": view_url,
                "format": "text/html",
            }

            # create a sequence and add canvases
            seq = manifest.sequence()  # unlabeled, anonymous sequence
            # get images based on start/end locus for this shelfmark
            images = []
            for img in tei.image_urls:
                # special case for MS. Heb. e. 58 (R), which has two fragments in one recto image,
                # but separate verso images, and the verso images are numbered incorrectly
                if "MS_HEB_e_58_R" in img:
                    if (
                        not any(n in img for n in ["-2", "-3"])
                        or ("-2" in img and manifest_number == 1)
                        or ("-3" in img and manifest_number == 2)
                    ):
                        images.append(img)
                    continue
                # given an image url like MS_HEB_b_1_1a.tif we want just the 1 from "1a"
                try:
                    img_number = get_number(image_label(img, tei.desc.xml_id))
                except ValueError:
                    # there is one that simply doesn't have a number, MS_HEB_e_56_message.tif,
                    # so skip it
                    continue
                # add images matching this manifest's number to our list (1a, 1b, etc)
                if img_number == manifest_number:
                    # skip "extra" (e.g. the ones on MS Heb. e. 110), not part of MS
                    if "extra" not in img:
                        images.append(img)
                    else:
                        print("Found non-manuscript image %s; skipping" % img)

            # it seems unlikely that this will happen any more...
            if not images:
                print("No image found for %s; skipping" % (revised_shelfmark))
                continue

            # download images if necessary; generate labels and add to manifest
            for i, img_url in enumerate(images):
                # generate label from filename
                label = os.path.splitext(img_url)[0].split("_")[-1]
                # special case for MS. Heb. e. 58 (R), which is numbered incorrectly
                if "MS_HEB_e_58_R" in img_url:
                    label = (
                        "verso" if any(n in img_url for n in ["-2", "-3"]) else "recto"
                    )
                # simple case: a or b only; becomes recto/verso
                elif len(label) == 1 and not label.isdigit():
                    label = image_labels[label]
                elif label.isdigit():
                    # special case in MS. Heb. f. 111, folios not split recto/verso
                    label = "recto and verso"
                elif label.endswith("spread"):
                    # special case in d_73
                    label = "spread"
                else:
                    # some filenames have additional information, but
                    # still end with a or b; split out and convert a/b to r/v
                    last_digit = label[-1]
                    prefix = label[:-1]
                    # special case: prefix for MS Heb. c 13/6-8 should be 6-8
                    if "MS. Heb. c. 13/6-8" in revised_shelfmark:
                        prefix = "6-8"
                    side = image_labels[last_digit]
                    label = " ".join([v for v in [prefix, side] if v])

                # generate the url where we will download the full size version
                # images should be downloaded to original images folder
                output_path = image_output_path(image_dir, img_url)
                if not os.path.exists(output_path):
                    remote_url = "%s%s" % (
                        BASE_IMG_URL,
                        img_url.replace(".tif", ".jpg"),
                    )
                    resp = requests.get(remote_url)
                    if resp.status_code == requests.codes.ok:
                        with open(output_path, "wb") as outfile:
                            outfile.write(resp.content)
                    else:
                        print("%s error on %s; skipping" % (resp.status_code, img_url))
                        continue

                if not download_only:
                    # add image to canvas
                    # prezi prefixes ident with canvas/ for us, so don't duplicate
                    # BUT: must include manifest id to ensure unique
                    canvas = seq.canvas(
                        ident="%s/%s" % (manifest_id, (i + 1)), label=label
                    )
                    # Create an annotation on the Canvas
                    # warns if identifier is not set, so let's set one
                    anno = canvas.annotation(ident="%s/anno1" % canvas.id)
                    # iiif image id is filename without extension
                    img_id = os.path.splitext(img_url)[0]
                    img = anno.image(img_id, iiif=True)
                    img.set_hw_from_iiif()
                    # set canvas dimensions to match image
                    canvas.height = img.height
                    canvas.width = img.width

            if not download_only:
                # save the manifest; keep it human-readable
                manifest.toFile(compact=False)


def check_images(teifiles, image_dir, tiff_dir):

    source_images = []

    for xmlfile in teifiles:
        tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)
        source_images.extend(tei.image_urls)
    print("%d source images" % len(source_images))

    missing_original = []

    for image in source_images:
        # check if the original is present
        output_path = image_output_path(image_dir, image)
        if not os.path.exists(output_path):
            missing_original.append(image)

    if missing_original:
        print("Missing %d original images" % len(missing_original))
        for img in missing_original:
            print("  %s" % img)
    else:
        print("No original images missing")

    missing_tiff = []
    for image in source_images:
        # check if the expected tiff is present
        if image not in missing_original and not os.path.exists(
            os.path.join(tiff_dir, image)
        ):
            missing_tiff.append(image)

    if missing_tiff:
        print("Missing %d tiffs" % len(missing_tiff))
        for img in missing_tiff:
            print("  %s" % img)
    else:
        print("No tiffs missing")

    # summarize
    print(
        "%d source images; %d original images missing; %d tiffs missing"
        % (len(source_images), len(missing_original), len(missing_tiff))
    )


if __name__ == "__main__":
    # needs xml filenames and destination dir as input
    parser = argparse.ArgumentParser(
        description="Generate IIIF manfiests from Bodleian Genizah TEI + images."
    )
    parser.add_argument(
        "tei", metavar="TEIXML", nargs="+", help="TEI files to be processed"
    )
    parser.add_argument(
        "-d",
        "--dir",
        metavar="DEST_DIR",
        help="base directory where manifest and images will be placed",
        required=True,
    )
    parser.add_argument(
        "-u",
        "--url",
        metavar="URL",
        help="base url where manifests will be served",
        default="https://princetongenizalab.github.io/iiif/bodleian/",
    )
    parser.add_argument(
        "-i",
        "--image-dir",
        help="Where to download original images",
    )
    parser.add_argument(
        "--download-only",
        help="Only download original images, don't generate manifests",
        action="store_true",
    )
    parser.add_argument(
        "-t",
        "--tiff-dir",
        help="Location for pyramidal tiffs (only used with check-images)",
    )
    parser.add_argument(
        "--check-images",
        action="store_true",
        help="Check that all expected images are present",
    )

    args = parser.parse_args()

    if args.check_images:
        print("checking images")
        check_images(args.tei, args.image_dir, args.tiff_dir)

    else:
        # url is required if not checking images
        if not args.url:
            print("Base url is required")
            parser.print_help()
            exit(-1)

        for teifile in args.tei:
            parse_bodleian_tei(
                teifile,
                args.dir,
                base_url=args.url,
                image_dir=args.image_dir,
                download_only=args.download_only,
            )
