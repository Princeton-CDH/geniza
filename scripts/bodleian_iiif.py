#! /usr/bin/env python

# Stand-alone python script to generate IIIF manifests
# for Bodleian Genizah content.
#
# Bodleian Genizah TEI files are available in the collections folder
# of this GitHub repository: https://github.com/bodleian/genizah-mss
#
# Install python dependencies with pip:
#
#   pip install eulxml python-slugify requests iiif iiif-prezi
#
# Run with the path to one or more Bodleian TEI files:
#
#   python scripts/bodleian_iiif.py ../genizah-mss/collections/MS_Heb_f_30.xml

import argparse
import os
import os.path
import re
import sys

import requests
from eulxml import xmlmap
from eulxml.xmlmap import teimap
from iiif.static import IIIFStatic, IIIFStaticError
from iiif_prezi.factory import ManifestFactory
from slugify import slugify

# parse bodleian tei files, generate iiif manifests,
# and download original images;

# in bodleian tei repo,
# collections is a directory of xml files
# each file has multiple records

# full-size images referenced in TEI can be downloaded in JPG format
# under this base image url
BASE_IMG_URL = "https://genizah.bodleian.ox.ac.uk/fragments/full/"

# base url for the manifest ids (prelim/testing)
PUBLIC_URL = "http://0.0.0.0:8001/bodleian/"


# TODO: need to generate a csv of shelfmark + manifest urls (add/update)
# for use with importing into pgp app
# (and where do we convert shelfmarks to PGP convention?)
# (separate script)


# define eulxml.xmlmap objects with mapping to the portions of the
# Bodleian XML we care about for generating manifests


class Shelfmark(teimap.Tei):
    xml_id = xmlmap.StringField("@xml:id")
    shelfmark = xmlmap.StringField("tei:msIdentifier/tei:altIdentifier/tei:idno")
    title = xmlmap.StringField("tei:msContents/tei:msItem/tei:title")

    @property
    def base_image_id(self):
        # generate expected image urls from shelfmark/xml id
        # - uses -N instead of -partN for sequence
        # - MS Heb is capitalized
        return self.xml_id.replace("-part", "_").replace("Heb", "HEB")


class BodleianGenizahTei(teimap.Tei):
    # extend eulxml TEI to add mappings for the fields we need
    # to generate iiif content

    # volume id on the TEI element
    volume_id = xmlmap.StringField("@xml:id")
    # records with shelfmarks are in msPart
    parts = xmlmap.NodeListField("//tei:msPart", Shelfmark)
    # images are all listed as graphics under facsimile
    image_urls = xmlmap.StringListField("//tei:facsimile/tei:graphic/@url")


# bodleian image filenames end with a or b;
# translate those to recto/verso for lbaels
image_labels = {"a": "recto", "b": "verso"}

# common metadata to include in all manifests
common_metadata = {
    "Provenance": "Static IIIF generated by Center for Digital Humanities and Princeton and Princeton Geniza Lab from Bodleian Libraries, University of Oxford"
}
attribution = "Images Â© Bodleian Libraries, University of Oxford. <a href=\"https://creativecommons.org/licenses/by-nc/4.0/\">CC-BY-NC 4.0</a>. For more information, please <a href='https://genizah.bodleian.ox.ac.uk/terms'>Terms of Use</a>."
license_uri = "https://creativecommons.org/licenses/by-nc/4.0/"

# attribution adapted from one of their digital bodleian manifests,
# but linking to Genizah site Terms of Use
# https://iiif.bodleian.ox.ac.uk/iiif/manifest/01bc51ec-80fb-4318-aaf3-bc313692691f.json

# logo image from a bodleian manifest
bodleian_logo = "https://iiif.bodleian.ox.ac.uk/iiif/image/f27e28db-0b08-4f16-9bdf-3565f591fb71/full/256,/0/default.jpg"

# format string for generating view url
view_url_format = "https://genizah.bodleian.ox.ac.uk/catalog/%(volume_id)s#%(item_id)s"


def parse_bodleian_tei(xmlfile, base_dir):
    print("Processing %s" % xmlfile)
    tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)

    # TODO: revise these for planned repo setup
    base_path = os.path.join(base_dir, "bodleian")
    manifest_dir = os.path.join(base_path, "manifests")
    image_dir = os.path.join(base_path, "images_orig")

    # determine path based on the collection filename and part id
    basename = os.path.splitext(os.path.basename(xmlfile))[0]

    # make sure output dirs exist
    os.makedirs(manifest_dir, exist_ok=True)
    os.makedirs(image_dir, exist_ok=True)

    # initialize manifest factory with base urls and iiif api version
    fac = ManifestFactory()
    # Where the resources live on the web
    fac.set_base_prezi_uri(PUBLIC_URL + "manifests/")
    # Where the resources live on disk
    fac.set_base_prezi_dir(manifest_dir)

    # Default Image API information
    fac.set_base_image_uri(PUBLIC_URL + "iiif-images/")
    fac.set_iiif_image_info(2.0, 0)  # Version, ComplianceLevel

    # keep a list of images so we can generate iiif tiles for them
    orig_images = []

    for part in tei.parts:
        # create a new manifest; save to filename based on shelfmark
        # instead of manifest.json
        manifest = fac.manifest(
            ident=slugify(part.shelfmark), label=str(part.shelfmark)
        )
        manifest.viewingHint = "individuals"
        manifest.attribution = attribution
        manifest.license = license_uri
        # TODO: link to the bodleian's official page for the volume
        # should we show their logo ?
        manifest.set_metadata(common_metadata)

        # set bodleian logo
        manifest.logo = bodleian_logo

        # use title from xml as manifest description
        manifest.description = str(part.title)

        # construct link to this item on Bodleian Genizah site
        view_url = view_url_format % {
            "volume_id": tei.volume_id,
            "item_id": part.xml_id,
        }
        print(view_url)
        manifest.rendering = {
            "@id": view_url,
            "format": "text/html",
        }

        # create a sequence and add canvases
        seq = manifest.sequence()  # unlabeled, anonymous sequence
        # use regex to find corresponding images
        # (matches image id with following non-digit; i.e., don't match 1 to 10 etc)
        images = [
            i for i in tei.image_urls if re.match("%s[^\d]" % part.base_image_id, i)
        ]
        # in some cases, expected images are not found; should investigate
        if not images:
            print(
                "No images found for %s (%s); skipping"
                % (part.shelfmark, part.base_image_id)
            )
            continue

        # download images if necessary; generate labels and add to manifest
        for i, img_url in enumerate(images):
            # generate label from filename
            label = os.path.splitext(img_url.replace(part.base_image_id, ""))[0]
            # simple case: a or be only; becomes recto/verso
            if len(label) == 1:
                label = image_labels[label]
            else:
                # some filenames have additional information, but
                # still end with a or b; split out and convert a/b to r/v
                last_digit = label[-1]
                prefix = label[:-1]
                side = image_labels[last_digit]
                label = " ".join([v for v in [prefix, side] if v])

            # generate the url where we can download the full size version
            # - xml references tiffs but version online is jpg
            img_url = img_url.replace(".tif", ".jpg")
            # images should be downloaded to original images folder
            output_path = os.path.join(image_dir, img_url)
            # add to list of images to generate tiles
            orig_images.append(output_path)
            if not os.path.exists(output_path):
                remote_url = "%s%s" % (BASE_IMG_URL, img_url.replace(".tif", ".jpg"))
                print(remote_url)
                resp = requests.get(remote_url)
                if resp.status_code == requests.codes.ok:
                    with open(output_path, "wb") as outfile:
                        outfile.write(resp.content)
                else:
                    print("%s error on %s; skipping" % (resp.status_code, img_url))
                    continue

            # add image to canvas
            # prezi prefixes ident with canvas/ for us, so don't duplicate
            canvas = seq.canvas(ident="%s" % (i + 1), label=label)
            # Create an annotation on the Canvas
            # warns if identifier is not set, so let's set one
            anno = canvas.annotation(ident="%s/anno1" % canvas.id)
            # image id for iiif will be based on filename
            img_id = os.path.splitext(img_url)[0]
            img = anno.image(img_id, iiif=True)
            img.set_hw_from_file(output_path)
            # set canvas dimensions to match image
            canvas.height = img.height
            canvas.width = img.width

        # save the manifest; keep it human-readable
        manifest.toFile(compact=False)


if __name__ == "__main__":
    # needs xml filenames and destination dir as input
    parser = argparse.ArgumentParser(
        description="Generate static IIIF from Bodleian Genizah TEI + images."
    )
    parser.add_argument(
        "tei", metavar="TEIXML", nargs="+", help="TEI files to be processed"
    )
    parser.add_argument(
        "-d",
        "--dir",
        metavar="DEST_DIR",
        help="base directory where manifest and images will be placed",
        required=True,
    )
    args = parser.parse_args()

    for teifile in args.tei:
        parse_bodleian_tei(teifile, args.dir)
