#! /usr/bin/env python

# Stand-alone python script to generate IIIF manifests
# for Bodleian Genizah content.
#
# Bodleian Genizah TEI files are available in the collections folder
# of this GitHub repository: https://github.com/bodleian/genizah-mss
#
# Install python dependencies with pip:
#
#   pip install eulxml python-slugify requests iiif iiif-prezi
#
# Run with the path to one or more Bodleian TEI files. You must also
# specify an output directory and a base url where the iiif content
# will be published. For example:
#
#   python scripts/bodleian_iiif.py -d ../iiif/bodleian \
#       -u https://princetongenizalab.github.io/iiif/bodleian/ \
#       ../genizah-mss/collections/MS_Heb_f_30.xml

import argparse
import os
import os.path
import re
import sys

import requests
from eulxml import xmlmap
from eulxml.xmlmap import teimap
from iiif.static import IIIFStatic, IIIFStaticError
from iiif_prezi.factory import ManifestFactory
from slugify import slugify

# parse bodleian tei files, generate iiif manifests,
# and download original images;

# in bodleian tei repo,
# collections is a directory of xml files
# each file has multiple records

# full-size images referenced in TEI can be downloaded in JPG format
# under this base image url
BASE_IMG_URL = "https://genizah.bodleian.ox.ac.uk/fragments/full/"

# bodleian IIIF images hosted by PUL
BASE_IIIF_IMG_URI = "https://puliiif.princeton.edu/iiif/2/"

# define eulxml.xmlmap objects with mapping to the portions of the
# Bodleian XML we care about for generating manifests


class Shelfmark(teimap.Tei):
    xml_id = xmlmap.StringField("@xml:id")
    shelfmark = xmlmap.StringField("tei:msIdentifier/tei:altIdentifier/tei:idno")
    title = xmlmap.StringField("tei:msContents/tei:msItem/tei:title")

    # image range is indicated by locus from/to
    # <locus from="10a" to="20b"/>
    image_start = xmlmap.StringField("tei:msContents/tei:msItem/tei:locus/@from")
    image_end = xmlmap.StringField("tei:msContents/tei:msItem/tei:locus/@to")


class BodleianGenizahTei(teimap.Tei):
    # extend eulxml TEI to add mappings for the fields we need
    # to generate iiif content

    # volume id on the TEI element
    volume_id = xmlmap.StringField("@xml:id")
    # records with shelfmarks are in msPart
    parts = xmlmap.NodeListField("//tei:msPart", Shelfmark)
    # images are all listed as graphics under facsimile
    image_urls = xmlmap.StringListField("//tei:facsimile/tei:graphic/@url")


# bodleian image filenames end with a or b;
# translate those to recto/verso for lbaels
image_labels = {"a": "recto", "b": "verso"}

# common metadata to include in all manifests
common_metadata = {
    "Provenance": 'Static IIIF generated by the Center for Digital Humanities at Princeton and the Princeton Geniza Lab from <a href="http://genizah.bodleian.ox.ac.uk/">Genizah Fragments at the Bodleian Libraries</a>, University of Oxford.'
}
attribution = "Images Â© Bodleian Libraries, University of Oxford. <a href=\"https://creativecommons.org/licenses/by-nc/4.0/\">CC-BY-NC 4.0</a>. For more information, please see <a href='https://genizah.bodleian.ox.ac.uk/terms'>Terms of Use</a>."
license_uri = "https://creativecommons.org/licenses/by-nc/4.0/"

# attribution adapted from one of their digital bodleian manifests,
# but linking to Genizah site Terms of Use
# https://iiif.bodleian.ox.ac.uk/iiif/manifest/01bc51ec-80fb-4318-aaf3-bc313692691f.json

# logo image from a bodleian manifest
bodleian_logo = "https://iiif.bodleian.ox.ac.uk/iiif/image/f27e28db-0b08-4f16-9bdf-3565f591fb71/full/256,/0/default.jpg"

# format string for generating view url
view_url_format = "https://genizah.bodleian.ox.ac.uk/catalog/%(volume_id)s#%(item_id)s"


def image_output_path(image_dir, image_filename):
    # generate the path where we will save the full size version
    # - xml references tiffs but version online is jpg
    return os.path.join(image_dir, image_filename.replace(".tif", ".jpg"))


def image_label(image_filename):
    # given an image url like MS_HEB_b_1_1a.tif we want just the 1a portion
    return os.path.splitext(image_filename)[0].split("_")[-1]


def parse_bodleian_tei(xmlfile, base_dir, base_url, image_dir):
    print("Processing %s" % xmlfile)
    tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)

    # put manifests in the directory specified
    manifest_dir = base_dir

    # strip any trailing slash from base url to avoid double or missing slash
    base_url = base_url.rstrip("/")

    # determine path based on the collection filename and part id
    basename = os.path.splitext(os.path.basename(xmlfile))[0]

    # make sure output dirs exist
    os.makedirs(manifest_dir, exist_ok=True)
    os.makedirs(image_dir, exist_ok=True)

    # initialize manifest factory with base urls and iiif api version
    fac = ManifestFactory()
    # Where the resources live on the web
    fac.set_base_prezi_uri(base_url)
    # Where the resources live on disk
    fac.set_base_prezi_dir(manifest_dir)

    # Default Image API information
    fac.set_base_image_uri(BASE_IIIF_IMG_URI)
    fac.set_iiif_image_info(2.0, 2)  # Version, ComplianceLevel

    for part in tei.parts:
        # create a new manifest; save to filename based on shelfmark
        # instead of manifest.json

        # ident="%s/%s" % (slugify(series), slugify(shelfmark)),

        # group manifests, so that the directories will be more manageable.
        # use the first portion of the id (e.g., MS. Heb a.),
        # slugify, and then remove ms-heb- since all (almost all?) of them have that
        group = slugify("-".join(part.shelfmark.split(" ")[:3])).replace("ms-heb-", "")
        print(group)

        manifest = fac.manifest(
            ident="%s/%s" % (group, slugify(part.shelfmark)),
            label=str(part.shelfmark),
        )
        manifest.viewingHint = "individuals"
        manifest.attribution = attribution
        manifest.license = license_uri
        manifest.set_metadata(common_metadata)
        # set bodleian logo
        manifest.logo = bodleian_logo

        # use title from xml as manifest description
        manifest.description = str(part.title)

        # construct link to this item on Bodleian Genizah site
        view_url = view_url_format % {
            "volume_id": tei.volume_id,
            "item_id": part.xml_id,
        }
        manifest.rendering = {
            "@id": view_url,
            "format": "text/html",
        }

        # create a sequence and add canvases
        seq = manifest.sequence()  # unlabeled, anonymous sequence
        # get images based on start/end locus for this shelfmark
        images = []
        started = False
        for img in tei.image_urls:
            # given an image url like MS_HEB_b_1_1a.tif we want just the 1a
            img_label = image_label(img)
            if img_label == part.image_start:
                started = True
            # if we have found the start image, add images to our list
            if started:
                images.append(img)
            # when we get to the end image, stop processing
            if img_label == part.image_end:
                break

        # it seems unlikely that this will happen any more...
        if not images:
            print(
                "No images found for %s (%s to %s); skipping"
                % (part.shelfmark, part.image_start, part.image_end)
            )
            continue

        # download images if necessary; generate labels and add to manifest
        for i, img_url in enumerate(images):
            # generate label from filename
            label = os.path.splitext(img_url)[0].split("_")[-1]
            # simple case: a or be only; becomes recto/verso
            if len(label) == 1:
                label = image_labels[label]
            else:
                # some filenames have additional information, but
                # still end with a or b; split out and convert a/b to r/v
                last_digit = label[-1]
                prefix = label[:-1]
                side = image_labels[last_digit]
                label = " ".join([v for v in [prefix, side] if v])

            # generate the url where we will download the full size version
            # images should be downloaded to original images folder
            output_path = image_output_path(image_dir, img_url)
            if not os.path.exists(output_path):
                remote_url = "%s%s" % (BASE_IMG_URL, img_url.replace(".tif", ".jpg"))
                print(remote_url)
                resp = requests.get(remote_url)
                if resp.status_code == requests.codes.ok:
                    with open(output_path, "wb") as outfile:
                        outfile.write(resp.content)
                else:
                    print("%s error on %s; skipping" % (resp.status_code, img_url))
                    continue

            # add image to canvas
            # prezi prefixes ident with canvas/ for us, so don't duplicate
            canvas = seq.canvas(ident="%s" % (i + 1), label=label)
            # Create an annotation on the Canvas
            # warns if identifier is not set, so let's set one
            anno = canvas.annotation(ident="%s/anno1" % canvas.id)
            # iiif image id is filename without extension
            img_id = os.path.splitext(img_url)[0]
            img = anno.image(img_id, iiif=True)
            img.set_hw_from_iiif()
            # set canvas dimensions to match image
            canvas.height = img.height
            canvas.width = img.width

        # save the manifest; keep it human-readable
        manifest.toFile(compact=False)


def check_images(teifiles, image_dir, tiff_dir):

    source_images = []

    for xmlfile in teifiles:
        tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)
        source_images.extend(tei.image_urls)
    print("%d source images" % len(source_images))

    missing_original = []

    for image in source_images:
        # check if the original is present
        output_path = image_output_path(image_dir, image)
        if not os.path.exists(output_path):
            missing_original.append(image)

    if missing_original:
        print("Missing %d original images" % len(missing_original))
        for img in missing_original:
            print("  %s" % img)
    else:
        print("No original images missing")

    missing_tiff = []
    for image in source_images:
        # check if the expected tiff is present
        if not os.path.exists(os.path.join(tiff_dir, image)):
            missing_tiff.append(image)

    if missing_tiff:
        print("Missing %d tiffs" % len(missing_tiff))
        for img in missing_tiff:
            print("  %s" % img)
    else:
        print("No tiffs missing")

    # summarize
    print(
        "%d source images; %d original images missing; %d tiffs missing"
        % (len(source_images), len(missing_original), len(missing_tiff))
    )


if __name__ == "__main__":
    # needs xml filenames and destination dir as input
    parser = argparse.ArgumentParser(
        description="Generate IIIF manfiests from Bodleian Genizah TEI + images."
    )
    parser.add_argument(
        "tei", metavar="TEIXML", nargs="+", help="TEI files to be processed"
    )
    parser.add_argument(
        "-d",
        "--dir",
        metavar="DEST_DIR",
        help="base directory where manifest and images will be placed",
        required=True,
    )
    parser.add_argument(
        "-u",
        "--url",
        metavar="URL",
        help="base url where manifests will be served",
        default="https://princetongenizalab.github.io/iiif/bodleian/",
    )
    parser.add_argument(
        "-i",
        "--image-dir",
        help="Where to download original images",
    )
    parser.add_argument(
        "-t",
        "--tiff-dir",
        help="Location for pyramidal tiffs (only used with check-images)",
    )
    parser.add_argument(
        "--check-images",
        action="store_true",
        help="Check that all expected images are present",
    )

    args = parser.parse_args()

    if args.check_images:
        print("checking images")
        check_images(args.tei, args.image_dir, args.tiff_dir)

    else:
        # url is required if not checking images
        if not args.url:
            print("Base url is required")
            parser.print_help()
            exit(-1)

        for teifile in args.tei:
            parse_bodleian_tei(
                teifile, args.dir, base_url=args.url, image_dir=args.image_dir
            )
