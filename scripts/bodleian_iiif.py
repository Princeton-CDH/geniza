#! /usr/bin/env python

# Stand-alone python script to generate IIIF manifests
# for Bodleian Genizah content.
#
# Bodleian Genizah TEI files are available in the collections folder
# of this GitHub repository: https://github.com/bodleian/genizah-mss
#
# Install python dependencies with pip:
#
#   pip install eulxml python-slugify requests iiif iiif-prezi
#
# Run with the path to one or more Bodleian TEI files. You must also
# specify an output directory and a base url where the iiif content
# will be published. For example:
#
#   python scripts/bodleian_iiif.py -d ../iiif-bodleian \
#       -u https://princetongenizalab.github.io/iiif-bodleian/ \
#       ../genizah-mss/collections/MS_Heb_f_30.xml

import argparse
import os
import os.path
import re
import sys

import requests
from eulxml import xmlmap
from eulxml.xmlmap import teimap
from iiif.static import IIIFStatic, IIIFStaticError
from iiif_prezi.factory import ManifestFactory
from slugify import slugify

# parse bodleian tei files, generate iiif manifests,
# and download original images;

# in bodleian tei repo,
# collections is a directory of xml files
# each file has multiple records

# full-size images referenced in TEI can be downloaded in JPG format
# under this base image url
BASE_IMG_URL = "https://genizah.bodleian.ox.ac.uk/fragments/full/"


# define eulxml.xmlmap objects with mapping to the portions of the
# Bodleian XML we care about for generating manifests


class Shelfmark(teimap.Tei):
    xml_id = xmlmap.StringField("@xml:id")
    shelfmark = xmlmap.StringField("tei:msIdentifier/tei:altIdentifier/tei:idno")
    title = xmlmap.StringField("tei:msContents/tei:msItem/tei:title")

    # image range is indicated by locus from/to
    # <locus from="10a" to="20b"/>
    image_start = xmlmap.StringField("tei:msContents/tei:msItem/tei:locus/@from")
    image_end = xmlmap.StringField("tei:msContents/tei:msItem/tei:locus/@to")


class BodleianGenizahTei(teimap.Tei):
    # extend eulxml TEI to add mappings for the fields we need
    # to generate iiif content

    # volume id on the TEI element
    volume_id = xmlmap.StringField("@xml:id")
    # records with shelfmarks are in msPart
    parts = xmlmap.NodeListField("//tei:msPart", Shelfmark)
    # images are all listed as graphics under facsimile
    image_urls = xmlmap.StringListField("//tei:facsimile/tei:graphic/@url")


# bodleian image filenames end with a or b;
# translate those to recto/verso for lbaels
image_labels = {"a": "recto", "b": "verso"}

# common metadata to include in all manifests
common_metadata = {
    "Provenance": 'Static IIIF generated by the Center for Digital Humanities at Princeton and the Princeton Geniza Lab from <a href="http://genizah.bodleian.ox.ac.uk/">Genizah Fragments at the Bodleian Libraries</a>, University of Oxford.'
}
attribution = "Images Â© Bodleian Libraries, University of Oxford. <a href=\"https://creativecommons.org/licenses/by-nc/4.0/\">CC-BY-NC 4.0</a>. For more information, please see <a href='https://genizah.bodleian.ox.ac.uk/terms'>Terms of Use</a>."
license_uri = "https://creativecommons.org/licenses/by-nc/4.0/"

# attribution adapted from one of their digital bodleian manifests,
# but linking to Genizah site Terms of Use
# https://iiif.bodleian.ox.ac.uk/iiif/manifest/01bc51ec-80fb-4318-aaf3-bc313692691f.json

# logo image from a bodleian manifest
bodleian_logo = "https://iiif.bodleian.ox.ac.uk/iiif/image/f27e28db-0b08-4f16-9bdf-3565f591fb71/full/256,/0/default.jpg"

# format string for generating view url
view_url_format = "https://genizah.bodleian.ox.ac.uk/catalog/%(volume_id)s#%(item_id)s"


def get_output_dirs(base_dir):
    # define directories relative to base directory
    manifest_dir = os.path.join(base_dir, "iiif/manifests")
    image_dir = os.path.join(base_dir, "images-orig")

    return manifest_dir, image_dir


def image_output_path(image_dir, image_filename):
    # generate the path where we will save the full size version
    # - xml references tiffs but version online is jpg
    return os.path.join(image_dir, image_filename.replace(".tif", ".jpg"))


def image_label(image_filename):
    # given an image url like MS_HEB_b_1_1a.tif we want just the 1a portion
    return os.path.splitext(image_filename)[0].split("_")[-1]


def parse_bodleian_tei(xmlfile, base_dir, base_url):
    print("Processing %s" % xmlfile)
    tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)

    # define directories relative to base directory
    # manifest_dir = os.path.join(base_dir, "iiif/manifests")
    # image_dir = os.path.join(base_dir, "images-orig")
    manifest_dir, image_dir = get_output_dirs(base_dir)

    # strip any trailing slash from base url to avoid double or missing slash
    base_url = base_url.rstrip("/")

    # determine path based on the collection filename and part id
    basename = os.path.splitext(os.path.basename(xmlfile))[0]

    # make sure output dirs exist
    os.makedirs(manifest_dir, exist_ok=True)
    os.makedirs(image_dir, exist_ok=True)

    # initialize manifest factory with base urls and iiif api version
    fac = ManifestFactory()
    # Where the resources live on the web
    fac.set_base_prezi_uri(base_url + "/manifests/")
    # Where the resources live on disk
    fac.set_base_prezi_dir(manifest_dir)

    # Default Image API information
    fac.set_base_image_uri(base_url + "/images/")
    fac.set_iiif_image_info(2.0, 0)  # Version, ComplianceLevel

    for part in tei.parts:
        # create a new manifest; save to filename based on shelfmark
        # instead of manifest.json
        manifest = fac.manifest(
            ident=slugify(part.shelfmark), label=str(part.shelfmark)
        )
        manifest.viewingHint = "individuals"
        manifest.attribution = attribution
        manifest.license = license_uri
        manifest.set_metadata(common_metadata)
        # set bodleian logo
        manifest.logo = bodleian_logo

        # use title from xml as manifest description
        manifest.description = str(part.title)

        # construct link to this item on Bodleian Genizah site
        view_url = view_url_format % {
            "volume_id": tei.volume_id,
            "item_id": part.xml_id,
        }
        manifest.rendering = {
            "@id": view_url,
            "format": "text/html",
        }

        # create a sequence and add canvases
        seq = manifest.sequence()  # unlabeled, anonymous sequence
        # get images based on start/end locus for this shelfmark
        images = []
        started = False
        for img in tei.image_urls:
            # given an image url like MS_HEB_b_1_1a.tif we want just the 1a
            img_label = image_label(img)
            if img_label == part.image_start:
                started = True
            # if we have found the start image, add images to our list
            if started:
                images.append(img)
            # when we get to the end image, stop processing
            if img_label == part.image_end:
                break

        print(images)

        # it seems unlikely that this will happen any more...
        if not images:
            print(
                "No images found for %s (%s to %s); skipping"
                % (part.shelfmark, part.image_start, part.image_end)
            )
            continue

        # download images if necessary; generate labels and add to manifest
        for i, img_url in enumerate(images):
            # generate label from filename
            label = os.path.splitext(img_url)[0].split("_")[-1]
            # simple case: a or be only; becomes recto/verso
            if len(label) == 1:
                label = image_labels[label]
            else:
                # some filenames have additional information, but
                # still end with a or b; split out and convert a/b to r/v
                last_digit = label[-1]
                prefix = label[:-1]
                side = image_labels[last_digit]
                label = " ".join([v for v in [prefix, side] if v])

            # generate the url where we will download the full size version
            # images should be downloaded to original images folder
            output_path = image_output_path(image_dir, img_url)
            if not os.path.exists(output_path):
                remote_url = "%s%s" % (BASE_IMG_URL, img_url.replace(".tif", ".jpg"))
                print(remote_url)
                resp = requests.get(remote_url)
                if resp.status_code == requests.codes.ok:
                    with open(output_path, "wb") as outfile:
                        outfile.write(resp.content)
                else:
                    print("%s error on %s; skipping" % (resp.status_code, img_url))
                    continue

            # add image to canvas
            # prezi prefixes ident with canvas/ for us, so don't duplicate
            canvas = seq.canvas(ident="%s" % (i + 1), label=label)
            # Create an annotation on the Canvas
            # warns if identifier is not set, so let's set one
            anno = canvas.annotation(ident="%s/anno1" % canvas.id)
            # image id for iiif will be based on filename
            img_id = os.path.splitext(img_url)[0]
            img = anno.image(img_id, iiif=True)
            img.set_hw_from_file(output_path)
            # set canvas dimensions to match image
            canvas.height = img.height
            canvas.width = img.width

        # save the manifest; keep it human-readable
        manifest.toFile(compact=False)


def check_images(teifiles, base_dir):
    manifest_dir, image_dir = get_output_dirs(base_dir)
    iiif_dir = os.path.join(base_dir, "iiif/images")

    source_images = []

    for xmlfile in teifiles:
        tei = xmlmap.load_xmlobject_from_file(xmlfile, BodleianGenizahTei)
        source_images.extend(tei.image_urls)
    print("%d source images" % len(source_images))

    missing_original = []
    missing_iiif = []
    for image in source_images:
        # check if the original is present
        output_path = image_output_path(image_dir, image)
        if not os.path.exists(output_path):
            missing_original.append(image)

        # if not missing, check if we have iiif
        # (don't report on missing tiles for missing images!)
        else:
            identifier = os.path.splitext(os.path.basename(image))[0]
            # basic check: does the directory exist?
            if not os.path.isdir(os.path.join(iiif_dir, identifier)):
                missing_iiif.append(image)
            # could also check if info.json is present,
            # or if our extra tile sizes are present

    if missing_original:
        print("Missing %d original images" % len(missing_original))
        for img in missing_original:
            print("  %s" % img)
    else:
        print("No original images missing")

    if missing_iiif:
        print("Missing %d iiif images" % len(missing_iiif))
        for img in missing_iiif:
            print("  %s" % img)
    else:
        print("No iiif images missing")

    # summarize
    print(
        "%d source images; %d original images missing; %d iiif images missing"
        % (len(source_images), len(missing_original), len(missing_iiif))
    )


if __name__ == "__main__":
    # needs xml filenames and destination dir as input
    parser = argparse.ArgumentParser(
        description="Generate static IIIF from Bodleian Genizah TEI + images."
    )
    parser.add_argument(
        "tei", metavar="TEIXML", nargs="+", help="TEI files to be processed"
    )
    parser.add_argument(
        "-d",
        "--dir",
        metavar="DEST_DIR",
        help="base directory where manifest and images will be placed",
        required=True,
    )
    parser.add_argument(
        "-u",
        "--url",
        metavar="URL",
        help="base url where manifests will be served, excluding /manifests/ portion",
    )
    parser.add_argument(
        "--check-images",
        action="store_true",
        help="Check that all expected images and image tiles are present",
    )

    args = parser.parse_args()

    if args.check_images:
        print("checking images")
        check_images(args.tei, args.dir)

    else:
        # url is required if not checking images
        if not args.url:
            print("Base url is required")
            parser.print_help()
            exit(-1)

        for teifile in args.tei:
            parse_bodleian_tei(teifile, args.dir, base_url=args.url)
