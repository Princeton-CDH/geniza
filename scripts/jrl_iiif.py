#!/usr/bin/env python

# Stand-alone python script to generate remixed IIIF manifests
# for JRL (Rylands) Genizah content from Manchester UK.
#
# Takes a CSV of manifest urls as input.


import argparse
import csv
from urllib.parse import urlencode

from iiif_prezi.factory import ManifestFactory
from piffle.image import IIIFImageClient
from piffle.presentation import IIIFPresentation
from slugify import slugify

base_manifest_url = "https://princetongenizalab.github.io/iiif/jrl/"

manchester_logo = "https://princetongenizalab.github.io/iiif/jrl/umanchester_logo.png"

# common metadata to include in all manifests
common_metadata = {
    "Provenance": 'Remixed IIIF manifests generated by the Center for Digital Humanities at Princeton and the Princeton Geniza Lab from <a href="https://luna.manchester.ac.uk/luna/servlet/ManchesterDev~95~2">University of Manchester Genizah Collection</a>.'
}

base_image_uri = "https://luna.manchester.ac.uk/luna/servlet/iiif/"

# per access rights in JRL manifests
license_uri = "http://creativecommons.org/licenses/by-nc-sa/4.0/"
# combine image & access rights in their manifests
attribution = (
    "Image rights: The University of Manchester Library. Access rights: CC BY-NC-SA 4.0"
)

# TODO: rewrite to take csv with reference number;
# use pandas to ensure CSV is grouped and sorted as needed:
#   drop duplicates, report total
#   split reference number into shelfmark and sequence number,
#   group by shelfmark, sort by sequnce number
# then process groups


def combine_manifests(csvfilepath, output_dir):

    # initialize manifest factory with base urls and iiif api version
    fac = ManifestFactory()
    fac.set_debug("error")  # suppress warnings

    # Where the resources live on the web
    fac.set_base_prezi_uri(base_manifest_url)
    # Where the resources live on disk
    fac.set_base_prezi_dir(output_dir)

    # Default Image API information, based on manchester manifests
    fac.set_base_image_uri(base_image_uri)  # required by prezi...
    fac.set_iiif_image_info(2.0, 0)  # Version, ComplianceLevel

    manifest_count = 0

    with open(csvfilepath) as csvfile:
        csvreader = csv.DictReader(csvfile)

        current_shelfmark = new_manifest = None
        for row in csvreader:
            manifest_url = row["manifest_url"]
            # print(manifest_url)
            manifest = IIIFPresentation.from_url(manifest_url)
            # metadata is on the first canvas; shelfmark is labeled as "Reference number"
            # and includes a - # for the sequence
            canvas_metadata = {
                v.label: v.value for v in manifest.sequences[0].canvases[0].metadata
            }

            reference_number = canvas_metadata.get("Reference number")
            if not reference_number:
                print("error getting reference number from %s" % manifest_url)

            shelfmark, sequence = [
                part.strip() for part in reference_number.rsplit("-")
            ]
            if current_shelfmark == shelfmark:
                # add canvas + image from current manifest to the new one
                add_canvas_to_manifest(
                    manifest, seq, canvas_metadata["Folio"], reference_number
                )

            else:
                # save the previous manifest one if there is one
                if new_manifest:
                    print(
                        "Saving manifest for %s (%d images)"
                        % (current_shelfmark, len(new_manifest.sequences[0].canvases))
                    )
                    # save the manifest; keep it human-readable
                    new_manifest.toFile(compact=False)

                    manifest_count += 1

                    # bail out for testing
                    if manifest_count > 5:
                        return

                current_shelfmark = shelfmark
                # start new manifest
                series = shelfmark.split()[0]
                new_manifest = fac.manifest(
                    ident="%s/%s" % (slugify(series), slugify(shelfmark)),
                    label="JRL SERIES %s" % shelfmark,
                )
                new_manifest.viewingHint = "individuals"
                # set attribution
                new_manifest.attribution = attribution
                new_manifest.license = license_uri
                new_manifest.set_metadata(common_metadata)
                # set manchester logo
                new_manifest.logo = manchester_logo

                # add rendering url to view all the items
                # we're aggregating on the Manchester site
                new_manifest.rendering = {
                    "@id": get_view_url(shelfmark),
                    "format": "text/html",
                }

                # manifests don't include a meaningful description;
                # repeat shelfmark?
                new_manifest.description = (
                    canvas_metadata.get("Image Title") or reference_number
                )

                # create a sequence and add canvases
                seq = new_manifest.sequence()  # unlabeled, anonymous sequence

                # add canvas + image from current manifest to the new one;
                # use folio information from metadata,
                # since it provides additional information
                add_canvas_to_manifest(
                    manifest, seq, canvas_metadata["Folio"], reference_number
                )


def get_view_url(shelfmark):
    # link to search by reference number within the geniza collection
    search_opts = urlencode(
        {
            "q": 'reference_number="%s" LIMIT:ManchesterDev~95~' % shelfmark,
            "sort": "reference_number,date_created",
        }
    )
    return f"https://luna.manchester.ac.uk/luna/servlet/view/search?{search_opts}"


def add_canvas_to_manifest(
    remote_manifest, new_manifest_sequence, canvas_label, remote_manifest_label
):
    jrl_canvas = remote_manifest.sequences[0].canvases[0]
    jrl_image = jrl_canvas.images[0]
    # TODO: should we use folio metadata for label instead? (includes recto/verso)
    cvs = new_manifest_sequence.canvas(ident=jrl_canvas.id, label=canvas_label)
    cvs.set_hw(jrl_image.resource.height, jrl_image.resource.width)

    # Build the Image Annotation
    anno = cvs.annotation()  # prezi warns aout missing ident

    # get image service id; remove the base image uri required by prezi factory
    image_id = jrl_image.resource.service.id.replace(base_image_uri, "")
    img = anno.image(ident=image_id, iiif=True)
    img.set_hw(jrl_image.resource.height, jrl_image.resource.width)

    # adding provenance per recommendation from folks on IIIf Slack
    # to track original source of this canvas
    setattr(
        cvs,
        "partOf",
        [
            {
                "@id": remote_manifest.id,
                "@type": "sc:Manifest",
                # NOTE: JRL manifest labels are not useful,
                # using reference number (shelfmark + sequence) instead
                "label": {"en": ["original source: %s" % remote_manifest_label]},
            }
        ],
    )


if __name__ == "__main__":
    # needs xml filenames and destination dir as input
    parser = argparse.ArgumentParser(
        description="Generate remixed IIIF manifests from JRL IIIF."
    )
    parser.add_argument("csv", help="CSV file with list of manifest urls")
    parser.add_argument(
        "output_dir", help="Directory where generated manifests should be saved"
    )
    args = parser.parse_args()

    combine_manifests(args.csv, args.output_dir)
