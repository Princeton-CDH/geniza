#!/usr/bin/env python

# Stand-alone python script to generate remixed IIIF manifests
# for JRL (Rylands) Genizah content from Manchester UK.
#
# Takes a CSV of manifest urls as input.


import argparse
import os.path
from urllib.parse import urlencode

import pandas as pd
from iiif_prezi.factory import ManifestFactory
from piffle.presentation import IIIFPresentation
from ratelimit import limits
from rich.progress import Progress
from slugify import slugify

base_manifest_url = "https://princetongenizalab.github.io/iiif/jrl/"

manchester_logo = "https://princetongenizalab.github.io/iiif/jrl/umanchester_logo.png"

# common metadata to include in all manifests
common_metadata = {
    "Provenance": 'Remixed IIIF manifests generated by the Center for Digital Humanities at Princeton and the Princeton Geniza Lab from <a href="https://luna.manchester.ac.uk/luna/servlet/ManchesterDev~95~2">University of Manchester Genizah Collection</a>.'
}

base_image_uri = "https://luna.manchester.ac.uk/luna/servlet/iiif/"

# per access rights in JRL manifests
license_uri = "http://creativecommons.org/licenses/by-nc-sa/4.0/"
# combine image & access rights in their manifests
attribution = (
    "Image rights: The University of Manchester Library. Access rights: CC BY-NC-SA 4.0"
)

# use ratelimit to limit calls to 5 per second, based on
# observed ratelimit limit/reset headers in the iiif response


@limits(calls=5, period=1)
def get_manifest(url):
    return IIIFPresentation.from_url(url)


def combine_manifests(csvfilepath, output_dir):
    # use pandas to clean up the csv created by crawling
    # the jrl iiif geniza collection
    jrl_df = pd.read_csv(csvfilepath)
    initial_count = len(jrl_df)
    # because crawling was interrupted and restarted, we expect some dupes
    jrl_df.drop_duplicates(inplace=True)
    dedupe_count = len(jrl_df)
    # rename shelfmark to reference number
    jrl_df["reference_number"] = jrl_df.shelfmark
    # split reference number out into shelfmark and sequence within shelfmark
    # at least one case has - without surrounding spaces
    jrl_df[["shelfmark", "sequence"]] = jrl_df.reference_number.str.split(
        "-", n=1, expand=True
    )
    # remove any whitespace after splitting
    jrl_df.shelfmark = jrl_df.shelfmark.str.strip()
    jrl_df.sequence = jrl_df.sequence.str.strip()

    shelfmark_count = len(jrl_df.shelfmark.unique())
    print(
        "CSV has %d manifests (%d before deduplication) with %d unique shelfmarks"
        % (dedupe_count, initial_count, shelfmark_count)
    )
    # seems to be already in the order we want, but make sure
    jrl_df.sort_values(by=["shelfmark", "sequence"], inplace=True)

    # initialize manifest factory with base urls and iiif api version
    fac = ManifestFactory()
    fac.set_debug("error")  # suppress warnings

    # Where the resources live on the web
    fac.set_base_prezi_uri(base_manifest_url)
    # Where the resources live on disk
    fac.set_base_prezi_dir(output_dir)

    # Default Image API information, based on manchester manifests
    fac.set_base_image_uri(base_image_uri)  # required by prezi...
    fac.set_iiif_image_info(2.0, 0)  # Version, ComplianceLevel

    manifest_count = 0

    current_shelfmark = new_manifest = None

    with Progress(expand=True) as progress:
        task = progress.add_task("Combining manifests...", total=shelfmark_count)

        for row in jrl_df.itertuples():

            # skip if already generated in a previous run
            shelfmark = row.shelfmark
            series = shelfmark.split()[0]
            # path is based on manifest identifier, in output dir, with json extension
            expected_path = os.path.join(
                output_dir, "%s/%s.json" % (slugify(series), slugify(shelfmark))
            )
            if os.path.exists(expected_path):
                # update the count, to track progress/estimate
                progress.update(task, advance=1)
                continue

            manifest_url = row.iiif_url
            # print(manifest_url)
            manifest = get_manifest(manifest_url)
            # metadata is on the first canvas; shelfmark is labeled as "Reference number"
            # and includes a - # for the sequence
            canvas_metadata = {
                v.label: v.value for v in manifest.sequences[0].canvases[0].metadata
            }
            reference_number = row.reference_number

            # NOTE: not every record has a folio; use reference number as fallback
            folio = canvas_metadata.get("Folio", reference_number)
            # override folio to use "verso" for second image, in case of double recto
            if row.sequence == "2" and "recto" in folio:
                folio = folio.replace("recto", "verso")

            if current_shelfmark == shelfmark:
                # add canvas + image from current manifest to the new one
                add_canvas_to_manifest(
                    manifest,
                    seq,
                    folio,
                    reference_number,
                )

            else:
                # save the previous manifest one if there is one
                if new_manifest:
                    print(
                        "Saving manifest for %s (%d images)"
                        % (current_shelfmark, len(new_manifest.sequences[0].canvases))
                    )
                    # save the manifest; keep it human-readable
                    new_manifest.toFile(compact=False)
                    progress.update(task, advance=1)

                    # dev/debug, only process first N
                    # manifest_count += 1
                    # # bail out for testing
                    # if manifest_count > 5:
                    #     return

                current_shelfmark = shelfmark
                # start new manifest
                new_manifest = fac.manifest(
                    ident="%s/%s" % (slugify(series), slugify(shelfmark)),
                    label="JRL SERIES %s" % shelfmark,
                )
                new_manifest.viewingHint = "individuals"
                # set attribution
                new_manifest.attribution = attribution
                new_manifest.license = license_uri
                new_manifest.set_metadata(common_metadata)
                # set manchester logo
                new_manifest.logo = manchester_logo

                # add rendering url to view all the items
                # we're aggregating on the Manchester site
                new_manifest.rendering = {
                    "@id": get_view_url(shelfmark),
                    "format": "text/html",
                }

                # manifests don't include a meaningful description;
                # repeat shelfmark?
                new_manifest.description = (
                    canvas_metadata.get("Image Title") or reference_number
                )

                # create a sequence and add canvases
                seq = new_manifest.sequence()  # unlabeled, anonymous sequence

                # add canvas + image from current manifest to the new one;
                # use folio information from metadata (when available),
                # since it provides additional information
                add_canvas_to_manifest(
                    manifest,
                    seq,
                    folio,
                    reference_number,
                )

        # save the last manifest when the loop ends
        if new_manifest:
            print(
                "Saving manifest for %s (%d images)"
                % (current_shelfmark, len(new_manifest.sequences[0].canvases))
            )
            # save the manifest; keep it human-readable
            new_manifest.toFile(compact=False)


def get_view_url(shelfmark):
    # link to search by reference number within the geniza collection
    search_opts = urlencode(
        {
            "q": 'reference_number="%s" LIMIT:ManchesterDev~95~' % shelfmark,
            "sort": "reference_number,date_created",
        }
    )
    return f"https://luna.manchester.ac.uk/luna/servlet/view/search?{search_opts}"


def add_canvas_to_manifest(
    remote_manifest, new_manifest_sequence, canvas_label, remote_manifest_label
):
    jrl_canvas = remote_manifest.sequences[0].canvases[0]
    jrl_image = jrl_canvas.images[0]

    cvs = new_manifest_sequence.canvas(ident=jrl_canvas.id, label=canvas_label)
    cvs.set_hw(jrl_image.resource.height, jrl_image.resource.width)

    # Build the Image Annotation
    anno = cvs.annotation()  # prezi warns aout missing ident

    # get image service id; remove the base image uri required by prezi factory
    image_id = jrl_image.resource.service.id.replace(base_image_uri, "")
    img = anno.image(ident=image_id, iiif=True)
    img.set_hw(jrl_image.resource.height, jrl_image.resource.width)

    # adding provenance per recommendation from folks on IIIf Slack
    # to track original source of this canvas
    setattr(
        cvs,
        "partOf",
        [
            {
                "@id": remote_manifest.id,
                "@type": "sc:Manifest",
                # NOTE: JRL manifest labels are not useful,
                # using reference number (shelfmark + sequence) instead
                "label": {"en": ["original source: %s" % remote_manifest_label]},
            }
        ],
    )


if __name__ == "__main__":
    # needs xml filenames and destination dir as input
    parser = argparse.ArgumentParser(
        description="Generate remixed IIIF manifests from JRL IIIF."
    )
    parser.add_argument("csv", help="CSV file with list of manifest urls")
    parser.add_argument(
        "output_dir", help="Directory where generated manifests should be saved"
    )
    args = parser.parse_args()

    combine_manifests(args.csv, args.output_dir)
